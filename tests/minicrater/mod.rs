use common::CommandCraterExt;
use difference::Changeset;
use rand::{self, distributions::Alphanumeric, Rng};
use serde_json::{self, Value};
use std::path::PathBuf;
use std::process::Command;

fn execute(ex: &str, crate_select: &str) {
    let ex_dir = PathBuf::from("tests").join("minicrater").join(ex);
    let config_file = ex_dir.join("config.toml");
    let expected_file = ex_dir.join("results.expected.json");
    let actual_file = ex_dir.join("results.actual.json");

    let report_dir = ::tempfile::tempdir().expect("failed to create report dir");
    let ex_arg = format!(
        "--ex=minicrater-{}-{}",
        ex,
        rand::thread_rng()
            .sample_iter(&Alphanumeric)
            .take(10)
            .collect::<String>()
    );

    // Create local list in the temp work dir
    let out = Command::crater()
        .args(&["create-lists", "local"])
        .env("CRATER_CONFIG", &config_file)
        .status()
        .unwrap();
    assert!(out.success());

    // Define the experiment
    let out = Command::crater()
        .args(&[
            "define-ex",
            &ex_arg,
            "stable",
            "beta",
            &format!("--crate-select={}", crate_select),
        ]).env("CRATER_CONFIG", &config_file)
        .status()
        .unwrap();
    assert!(out.success());

    // Execute the experiment
    let out = Command::crater()
        .args(&["run-graph", &ex_arg])
        .env("CRATER_CONFIG", &config_file)
        .status()
        .unwrap();
    assert!(out.success());

    // Generate the report
    let out = Command::crater()
        .args(&["gen-report", &ex_arg])
        .env("CRATER_CONFIG", &config_file)
        .arg(report_dir.path())
        .status()
        .unwrap();
    assert!(out.success());

    // Read the JSON report
    let json_report = ::std::fs::read(report_dir.path().join("results.json"))
        .expect("failed to read json report");

    // Delete the experiment
    let out = Command::crater()
        .args(&["delete-ex", &ex_arg])
        .env("CRATER_CONFIG", &config_file)
        .status()
        .unwrap();
    assert!(out.success());

    // Load the generated JSON report
    let parsed_report: Value = serde_json::from_slice(&json_report).expect("invalid json report");
    let mut actual_report = serde_json::to_vec_pretty(&parsed_report).unwrap();
    actual_report.push(b'\n');

    // Load the expected JSON report
    let expected_report = ::std::fs::read(&expected_file).unwrap_or(Vec::new());

    // Write the actual JSON report
    ::std::fs::write(&actual_file, &actual_report)
        .expect("failed to write copy of the json report");

    let changeset = Changeset::new(
        &String::from_utf8(expected_report).expect("invalid utf-8 in the expected report"),
        &String::from_utf8(actual_report.clone()).expect("invalid utf-8 in the actual report"),
        "\n",
    );
    if changeset.distance != 0 {
        eprintln!(
            "Difference between expected and actual reports:\n{}",
            changeset
        );
        eprintln!("To expect the new report in the future run:");
        eprintln!(
            "$ cp {} {}\n",
            actual_file.to_string_lossy(),
            expected_file.to_string_lossy()
        );
        panic!("invalid report generated by Crater");
    }
}

#[ignore]
#[test]
fn run_small() {
    execute("small", "demo");
}

#[ignore]
#[test]
fn run_full() {
    execute("full", "local");
}
