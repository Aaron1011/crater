use crate::common::CommandCraterExt;
use assert_cmd::prelude::*;
use difference::Changeset;
use rand::{self, distributions::Alphanumeric, Rng};
use serde_json::{self, Value};
use std::env;
use std::path::PathBuf;
use std::process::Command;

trait CommandMinicraterExt {
    fn minicrater_exec(&mut self);
}

impl CommandMinicraterExt for Command {
    fn minicrater_exec(&mut self) {
        if env::var_os("MINICRATER_SHOW_OUTPUT").is_some() {
            assert!(self.status().unwrap().success());
        } else {
            self.assert().success();
        }
    }
}

struct MinicraterRun {
    ex: &'static str,
    crate_select: &'static str,
    multithread: bool,
    ignore_blacklist: bool,
}

impl MinicraterRun {
    fn execute(&self) {
        let ex_dir = PathBuf::from("tests").join("minicrater").join(self.ex);
        let config_file = ex_dir.join("config.toml");
        let expected_file = ex_dir.join("results.expected.json");
        let actual_file = ex_dir.join("results.actual.json");

        let threads_count = if self.multithread { num_cpus::get() } else { 1 };

        let report_dir = tempfile::tempdir().expect("failed to create report dir");
        let ex_arg = format!(
            "--ex=minicrater-{}-{}",
            self.ex,
            rand::thread_rng()
                .sample_iter(&Alphanumeric)
                .take(10)
                .collect::<String>()
        );

        // Create local list in the temp work dir
        Command::crater()
            .args(&["create-lists", "local"])
            .env("CRATER_CONFIG", &config_file)
            .minicrater_exec();

        // Define the experiment
        let crate_select = format!("--crate-select={}", self.crate_select);
        let mut define_args = vec!["define-ex", &ex_arg, "stable", "beta", &crate_select];
        if self.ignore_blacklist {
            define_args.push("--ignore-blacklist");
        }
        Command::crater()
            .args(&define_args)
            .env("CRATER_CONFIG", &config_file)
            .minicrater_exec();

        // Execute the experiment
        Command::crater()
            .args(&[
                "run-graph",
                &ex_arg,
                "--threads",
                &threads_count.to_string(),
            ])
            .env("CRATER_CONFIG", &config_file)
            .minicrater_exec();

        // Generate the report
        Command::crater()
            .args(&["gen-report", &ex_arg])
            .env("CRATER_CONFIG", &config_file)
            .arg(report_dir.path())
            .minicrater_exec();

        // Read the JSON report
        let json_report = ::std::fs::read(report_dir.path().join("results.json"))
            .expect("failed to read json report");

        // Delete the experiment
        Command::crater()
            .args(&["delete-ex", &ex_arg])
            .env("CRATER_CONFIG", &config_file)
            .minicrater_exec();

        // Load the generated JSON report
        let parsed_report: Value =
            serde_json::from_slice(&json_report).expect("invalid json report");
        let mut actual_report = serde_json::to_vec_pretty(&parsed_report).unwrap();
        actual_report.push(b'\n');

        // Load the expected JSON report
        let expected_report = ::std::fs::read(&expected_file).unwrap_or(Vec::new());

        // Write the actual JSON report
        ::std::fs::write(&actual_file, &actual_report)
            .expect("failed to write copy of the json report");

        let changeset = Changeset::new(
            &String::from_utf8(expected_report).expect("invalid utf-8 in the expected report"),
            &String::from_utf8(actual_report.clone()).expect("invalid utf-8 in the actual report"),
            "\n",
        );
        if changeset.distance != 0 {
            eprintln!(
                "Difference between expected and actual reports:\n{}",
                changeset
            );
            eprintln!("To expect the new report in the future run:");
            eprintln!(
                "$ cp {} {}\n",
                actual_file.to_string_lossy(),
                expected_file.to_string_lossy()
            );
            panic!("invalid report generated by Crater");
        }
    }
}

#[ignore]
#[test]
fn single_thread_small() {
    MinicraterRun {
        ex: "small",
        crate_select: "demo",
        multithread: false,
        ignore_blacklist: false,
    }
    .execute();
}

#[ignore]
#[test]
fn single_thread_full() {
    MinicraterRun {
        ex: "full",
        crate_select: "local",
        multithread: false,
        ignore_blacklist: false,
    }
    .execute();
}

#[ignore]
#[test]
fn single_thread_blacklist() {
    MinicraterRun {
        ex: "blacklist",
        crate_select: "demo",
        multithread: false,
        ignore_blacklist: false,
    }
    .execute();
}

#[ignore]
#[test]
fn single_thread_ignore_blacklist() {
    MinicraterRun {
        ex: "ignore-blacklist",
        crate_select: "demo",
        multithread: false,
        ignore_blacklist: true,
    }
    .execute();
}

#[ignore]
#[test]
fn multi_thread_full() {
    MinicraterRun {
        ex: "full",
        crate_select: "local",
        multithread: true,
        ignore_blacklist: false,
    }
    .execute();
}
